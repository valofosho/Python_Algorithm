#BOJ1931 (회의실 배정)
#TIL: sort 메소드는 인자를 여러개로 활용 가능하며, 우선순위는 할당 순서에 비례한다.
N=int(input())
lst=[]
for i in range(N):
    lst.append(list(map(int,input().split())))
lst.sort(key=lambda x: (x[1],x[0]))
Ft, count=0 ,0
for start, end in lst:
    if start>=Ft:
        count+=1
        Ft=end
print(count)


"""
생각생각생각생각생각생각생각
리스트의 0번쨰는 무조건적으로 카운팅이 되어야 한다.
그렇다면 두번째로 카운팅 되는 원소는 무슨 조건을 만족해야 하는가?
이 전에 추가된 원소의 Ft와 추가 예정인 원소의 St가 겹치는 경우는 않돼요
만약 추가 예정의 원소와 추가 

굳이굳이굳이굳이굳이 새로운 리스트에 할당하기 보다 카운팅을 하는 방식이 시간을 줄이는 데 도움
추가 예정인 녀석의 St가 0번째 원소의 Ft보다 크면 가능

for 문을 돌리는 경우가 애매~해
ex)
0번째 다음으로 1번을 추가했어
그러면 다음 2번을 테스트하는 것은 1번을 기준으로 하겠지?

결국 main으로 주요 쟁점은 
2d array 에서 인자를 두개로 하여 받아들인다.
그리고 그 값을 다시 for문 안에서 받아준다.
+ 0으로 설정한 첫 Ft를 통해 가장 첫 인자를 무조건적으로 받아준다.
"""
