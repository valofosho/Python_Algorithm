BOJ#5430

중요 처리 요건
- R 명령이 주어진다고 해서 모든 원소를 뒤바꾸는 연산 하면 X
- R 연산이 연속해서 짝수번 반복되면 바꿀 필요 x
- R 연산이 연속하더라도 홀수번 반복되면 바꿀 필요 o

- 모든 원소를 뒤바꾸는 연산이 필요가 없다
- 가장 중요한 것은 시간 복잡도를 줄이는 일
- Reverse() 연산의 경우 O(N)의 시간복잡도를 가져 연산 시간 많이 소요
- R 을 기준으로 문자열을 파싱할 경우:
	문자열에서 popleft나 popright
- 가장 첫 연산자가 R인지 D인지만 확인하게 되면
  문자열 자체를 바꿀 필요가 없다
  만약 R이 나온 뒤 D가 나오는 연산의 경우
  문자열이 Reverse 된 상태에서 Deletion 연산이 작용
  즉 원래 popleft()연산이 작용되어야 하나
  Reverse 연산의 작용 아래 popright()가 작용된다.
  *R->D의 경우 pop right
  *RR(N)->D의 경우 pop left

- 이 간단한 걸 몰라서 머리를 쳐박은 나의 논리력에 박수

- 이러면 가장 중요한 점은 파싱의 기준을 어떻게 잡을 것이냐
  만약 파싱의 기준을 R로 잡으면 파싱되어진 R이 먼지
  제일 좋은 방법은 split과 join으로 해당 연속 문자별로 나누고
  나눈 상태에서 각 len을 재서 R의 len을 홀짝 확인하고
  D연산을 그에 맞춰서 진행


